##1 two sum 求数组中两数和为target
一次遍历，使用哈希表记录数字，判断target - num是否在哈希表中

##6 zigzag conversion 按zigzag组织字符串，再输出 
使用多层vector保存每行的字母

##11 container with most water 板块序列中，找出两块板之间能盛的最多水量  
从两边往里靠，每次移动较小一方的板。类似贪心算法。 

##15 3sum 求数组中三数和为0的所有可能unique情况
先排序，然后从头往后找，每次找两数和为-a[i]，时间复杂度为O(n^2)

##16 3sum closest 找出数组中三数和和给定目标最接近
先排序，然后从头往后找，每次找的目标为-a[i]，找到则直接返回target，否则继续找

##18 4sum 求数组中四数和为0的所有unique情况
类似3sum，从排序，从左边找两数，然后再找两数和为0，时间复杂度为O(n^3)

##31 next permutation 求数组按大小排列的下一个较大数
O(n)时间复杂度，O(1)空间复杂度
从尾部往左，找出第一个满足a[i]<a[i+1]的数a[i]，然后从尾部找出第一个大于a[i]的数a[j]，i, j位置交换，接着a[i+1, ... n-1]之间的数值颠倒过来

##49 group anagrams 字符串数组按字符出现的次数分组 
使用哈希表记录每个字符串中各个字符出现的次数，并作为Key保存在另一个哈希表中。

##120 triangle 杨辉三角路径的最小和
O(n)的时间复杂度，自上向下计算
v[i] = min(v[i-1], v[i]) + triangle[i]

##138 copy list with random pointer 拷贝包含有随机指针的链表 
先拷贝一个链表p1->q1->p2->q2->p3->q3-> ...，接着拷贝随机指针 q->random = p->random->next，最后把p, q指针分离

##139 word break 字符串切分成词
1. 使用动态规划，复杂度为O(n^2) 
   dp[i] |= dp[j] && (s[j..i] in dict) (j=0,...,i)
2. 使用递归，指数复杂度
   helper(s, dict) => (sub in dict) && helper(left, dict)
说明：很多指数复杂度的递归考虑能否改成动态规划，动态规划实际上是添加备忘本，避免指数过程中的重复计算

##208 implement trie prefix tree 构建词的前缀树
map[c] => postfix

##209 minimum size subarray sum  连续数列其和不低于s的最小区间长
使用queue，保证queue中和不低于s，大于s时则左边元素出队列，以求得最小值

##213 house robber ii  环形房子抢钱，要求相邻两家不能同时被抢，求最大抢钱数
分奇偶计算 a = max(b, a+nums[i])   b = max(a, b+nums[i])算出来直线型的最大；
再计算[0,n-2] 和[1,n-1] 中的最大值，值得注意的是，注意房子数为1的情况

##274 h-index H指数 
排序 + 自右往左判断

##284 peeking iterator 增加支持peek(指下一个next)的函数
增加 cur 和 curValid 两个变量，分别指明下一个next的变量，以及cur是否有效。

##299 bulls and cows 计算两字符串匹配字符个数、匹配位置个数
匹配位置个数 + 匹配字符个数 = 相同字符出现的个数

##368 largest divisible subset 数组中能连续整除的最大个数
先排序，在使用动态规划由右往左计算 dp[i] = (max(dp[j]) or 0) + 1，其中 nums[j]>=nums[i]

##377 combination sum iv 多个面值不一样的硬币组合成目标的序列个数，不同排序算不同的序列
1.考虑顺序列时(考虑i的最后一个元素为num)，对位置作外侧循环，内层为硬币种类，复杂度为O(n^2): dp[i] += dp[i - num]
2.不考虑顺序列时，对硬币种类作循环，复杂度为O(n): dp[i] += dp[i-num]

##380 insert delete getrandom O(1) 插入删除随机O(1) 
删除一个元素时，vector back => 删除位置，再pop_back，从而保证删除元素时复杂度也是O(1)
说明：vector删除一个元素时，可以把back挪到删除位置，再popback，则复杂度为O(1)

##386 lexicographial numbers 按字典顺序输出1-n的数字
使用递归   
helper(val) => visit(val) 
               for i = 0, 9 do helper(10*val + i)

##394 decode string   包含xx[yyy]型的字符串解码，xx表示重复次数
按照本身的定义可以使用递归，找出一对匹配的[]，然后进行分解： AB(f(A)+f(B)) 或 nA (n * f(A)) 的形式，递归可得。

##399 evaluate division 计算变量商值 
找出有关联的变量，即找图的联通分量，每个联通子图中一律用其中一个变量来表示: 
b = ?? * a, c = ?? * a, ...

##449 serialize and deserialize bst 二叉搜索树序列化和反序列化
序列化时，先根序遍历，变量值后加一个空格；反序列化时，维护一个栈，当前节点值小于栈顶节点值时，是其左节点，否则栈不断出栈，直到最后一个小于当前节点的节点，表明当前节点是其右孩子，最后当前节点入栈。

##467 unique substrings in wraparround string 在无穷字母表连环中，找出给定字符串的unique子串的出现次数
记录以字符x开头的连续子串的最大长度，则其长度==以x开头的子串的个数

##525 contiguous array 找出出现等次数0和1的连续序列的最大长度
其中一个数字标记为1，另一数字标记为-1，等次数的连续序列 => sum = 0
s1 == s2 => p1,p2间的和为0 => 等次数

##592 fraction addition and subtraction 分数加减
a/b + c/d = (ad + bc)/(bd) => 再约分

##609 find duplicate file in system 寻找系统中有重复内容的文件
map<content, vector<path>> m 按内容索引文件名数组

##611 valid triangle number 求数组中能组成三角形的个数
先排序，对数组遍历， 使用队列保存当前右边能组成三角形的两边，对新遍历的边，如果无法再组成三角形了，则队列头部出头，复杂度为O(n^2)。

##621 task Scheduler 任务调度最小花费时间
按任务次数从大到小排序，每次从可选任务中选择剩余次数最大的，如果都不可选，则选择冷却时间最小的

#623 add one row to tree 树中添加一层子节点

##624 maximum distance in arrays 多个已排序数列的最大间隔差
一次遍历，记下当前数组和之前最大最小值的最大间隔，接着更新当前的最大最小值
